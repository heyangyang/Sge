package com.sunny.game.engine.weather{	import com.sunny.game.engine.particle.SParticle;	import flash.display.BitmapData;	import flash.display.DisplayObjectContainer;	import flash.display.Shape;	import flash.filters.BlurFilter;	import flash.geom.Rectangle;	/**	 *	 * <p>	 * SunnyGame的雪花	 * </p>	 * <p><strong><font color="#0000ff">Copyright © 2012 Sunny3D. All rights reserved.</font></strong><br>	 * <font color="#0000ff">www.sunny3d.com</font></p>	 * @langversion 3.0	 * @playerversion Flash 11.2	 * @playerversion AIR 3.2	 * @productversion Flex 4.5	 * @author <strong><font color="#0000ff">刘黎明</font></strong><br>	 * <font color="#0000ff">www.liuliming.org</font>	 *	 */	public class SSnowflake extends SParticle	{		// the x and y velocity of the snowflake		public var xVel : Number;		public var yVel : Number;		// the size of the snowflake		private var _zoomRate : Number;		// and the limits of the screen		public var screenArea : Rectangle;		private var _bottom : int;		private var _decreaseAlpha : Number = 0;		private var _dropHeight : int;		private static var gBitmapData : BitmapData = null;		public function SSnowflake(parent : DisplayObjectContainer, screenarea : Rectangle)		{			super(parent);			if (!gBitmapData)			{				var dot : Shape = new Shape();				dot.graphics.lineStyle(3, 0xffffff);				dot.graphics.moveTo(0, 0);				dot.graphics.lineTo(0.2, 0.2);				dot.graphics.endFill();				gBitmapData = new BitmapData(dot.width, dot.height);				gBitmapData.draw(dot);			}			this.bitmapData = gBitmapData;			resetProperties();			setViewRect(screenarea);		}		public function resetProperties() : void		{			// and a notional z value for the 3D flake. 			// this is merely used to calculate the _zoomRate the 			// flake should be. 			// (we could just give it a random _zoomRate but 			// the distribution wouldn't look as nice)			var z : Number = (Math.random() * 600) - 250;			// and calculate the _zoomRate the flake would be 			// if the flake was that z distance from the camera			_zoomRate = calculatePerspectiveSize(z);//			_zoomRate = Number((0.5 + Math.random() * 0.5).toFixed(2));//			_zoomRate = _zoomRate < 0.4 ? 0.4 : _zoomRate;			_zoomRate = _zoomRate > 2 ? 2 : _zoomRate;			// let's scale up or down depending on how big we should be at			// this distance			scaleX = scaleY = _zoomRate;			// if the z position is close to the camera			// then let's give it a depth of field blur!			// (z gets smaller as it moves towards the camera			//  and the blur amount gets bigger)			if (z < -150)			{				// z will never be less than -250 so if we add 150 to it we				// should have a number between -100 and 0				var bluramount : Number = z + 150;				// so now if we divide by -100 we should have a number between 0 and 1				bluramount /= -100;				// so if we want a blur amount between 2 and 22, we now have to multiply by 20 				// and add 2				bluramount = (bluramount * 20) + 2;				// and now add a blur filter to the filters array with that blur amount				filters = [new BlurFilter(bluramount, bluramount, 2)];			}			else			{				// let's add a small blur filter to all the snowflakes anyway 				// to make them look a bit fluffier				filters = [new BlurFilter(2, 2, 2)];			}			// if we cache this sprite as a bitmap, the Flash players stores it			// as a bitmap which renders MUCH faster. 			// NB! If you rescale or rotate this sprite, then the Flash player 			// will re-render it and then store the bitmap again, which is actually 			// slower than not setting cacheAsBitmap! 			//cacheAsBitmap = true;			// now set a random x velocity between -1 and 1			xVel = ((Math.random() * 2) - 1) / 30;			// and a constant downward velocity of 3 (gravity)			yVel = 0.1;			// now let's multiply the velocity by the scale, 			// so that things in the foreground appear to move 			// faster			xVel *= _zoomRate;			yVel *= _zoomRate;			_decreaseAlpha = yVel / 200; //Math.abs(1 / ((_bottom - y) / yVel));		}		public function setViewRect(viewRect : Rectangle) : void		{			screenArea = viewRect;			// 计算生成周期			_dropHeight = Math.abs(_zoomRate * (screenArea.height));			// set the x position to a random position somewhere 			// within the width of the screen area			x = screenArea.x + Math.random() * screenArea.width;			_bottom = y + _dropHeight;			_bottom = _bottom > screenArea.bottom ? screenArea.bottom : _bottom;		}		public function update(wind : Number, offsetX : Number, offsetY : Number, deltaTime : int) : void		{			x += xVel * deltaTime - offsetX;			y += yVel * deltaTime - offsetY + Math.random();			x += (wind * _zoomRate);			if (y > _bottom)			{				y = screenArea.top + y % _bottom;				var windFactor : int = wind * xVel * 10;				x = windFactor + screenArea.x + Math.random() * (screenArea.width - windFactor);			}			if (x > screenArea.right)				x = screenArea.left;			else if (x < screenArea.left)				x = screenArea.right;		}		public function calculatePerspectiveSize(z : Number) : Number		{			// an arbitrary field of view (ish)			var fov : Number = 300;			// dodgy magic function to calculate the scale factor for			// an object at the specified z position			return fov / (z + fov);		}		override public function destroy() : void		{			super.destroy();		}	}}